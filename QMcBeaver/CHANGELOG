Fri, 9 Jul 2004, Daniel R. Fisher

1.  Added QMCEquilibrationArray.  This defines an array of
    QMCExtendedProperties objects, each of which consists of a
    QMCProperties object and equilibration and propagation
    Stopwatches.  The ith element of the array starts collecting
    statistics on the (2^i)th iteration of the run.  When the
    properties are gathered, the element of the array with the
    smallest standard deviation for the total energy is chosen and
    sent to the root processor.  
    When the timing information is collected, the propagation and
    equilibration timers from the appropriate QMCExtendedProperties
    object are added to the localTimers and sent to the root
    processor.
    When correlated sampling configurations are read, each processor
    determines how many configurations from the beginning of the file
    should be skipped.  
    To use the equilibration array, set the flag
    use_equilibration_array to 1.

Wed, 7 Jul 2004, Daniel R. Fisher

1.  Added QMCDansWalkerInitialization.  This initialization method requires
    very few equilibration steps before statistics can be gathered.  To use it,
    set the walker_initialization_method flag to dans_walker_initialization and
    copy radial_dist_arrays and angle_dist_arrays from the QMcBeaver/src 
    directory into the working directory.
    As part of this method, I added some quaternion operations for calculating
    rotations to Array1D.h.

2.  Added an equilibration Stopwatch to QMCStopwatches.  The time spent
    equilibrating the chain is now referred to as "equilibration time" and is
    recorded by the equilibration Stopwatch.  The Stopwatch that used to record
    this time was called the initialization Stopwatch.  This Stopwatch now 
    records the time spent generating an initial configuration for the 
    electrons.    


Thu, 1 Jul 2004, Daniel R. Fisher

1.  In QMCManager and QMCFlags, I made sure the iseed is always a negative
    integer whenever an input, restart, or checkpoint file is written or read.
    Previously, when a checkpoint or restart file was written, the current
    value of iseed, which during a run is a positive integer, was written.
    This was a problem for restarting parallel jobs from checkpoints because
    ran1() sets the iseed to 1 if it is positive, so all the processors were
    getting the same sequence of numbers.
    When writing restarts and checkpoints, -1*iseed is written out if
    iseed is positive.  I was careful not to change the value of iseed itself.

2.  In QMCManager, I fixed the conditional statement for writing out
    correlated sampling configurations.  Previously, it was writing out
    configs on every iteration, which caused very large files in the temp
    directory and very slow line search optimizations.  Now it writes out
    configs at the proper interval.
