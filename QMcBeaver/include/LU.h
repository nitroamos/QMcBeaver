//            QMcBeaver
//
//         Constructed by 
//
//     Michael Todd Feldmann 
//              and 
//   David Randall "Chip" Kent IV
//
// Copyright 2000.  All rights reserved.
//
// drkent@users.sourceforge.net mtfeldmann@users.sourceforge.net

#ifndef CKLUDCMP_H
#define CKLUDCMP_H

#include <math.h>
#include <iostream>
#include "Array2D.h"
#include "Array1D.h"

#ifdef USELAPACK
#include "cpplapack.h"
#endif

using namespace std;

/**
  @file LU.h
  Library of matrix functions which involve LU decompositions.
  */

/**
  LU decomposition using the algorithm in numerical recipes for a dense matrix.

  
  @param a a \f$N \times N\f$ matrix which is destroyed during the operation.
  The resulting LU decompositon is placed here.
  @param indx a \f$N\f$ dimensional array which records the row permutation 
  from partial pivoting.
  @param d used to give det(a) the correct sign
  @param calcOK returns false if the calculation is singular and true otherwise
  */

void ludcmp(Array2D <qmcfloat>& a, int *indx, double *d, bool *calcOK);


/**
  LU backsubstitution using the algorithm in numerical
  recipes for a dense matrix. 

  @param a the LU decomposition of a matrix produced by ludcmp
  @param indx a \f$N\f$ dimensional array which records the row permutation 
  from partial pivoting generated by ludcmp
  @param b the \f$N\f$ dimensional array right hand side of the system of 
  equations to solve
  */

void lubksb(Array2D <qmcfloat>& a, int *indx, Array1D<qmcfloat>& b);

/**
  LU backsubstitution using the algorithm in numerical
  recipes for a dense matrix. This has been modified to assume
	that we're solving for an inverse.
  
  I haven't found any tricks thus far...

  @param a the LU decomposition of a matrix produced by ludcmp
  @param indx a \f$N\f$ dimensional array which records the row permutation 
  from partial pivoting generated by ludcmp
  @param b the \f$N\f$ dimensional array right hand side of the system of 
  equations to solve, only to store the result
	@param which assuming inverse calculation, only one element of b will be non-zero
  */

void lubksbForInverse(Array2D <qmcfloat>& a, int *indx, Array1D<qmcfloat> &b, int which);

/**
  Calculates a determinant of a matrix using a dense LU solver.  
  This method scales
  as \f$O(\frac{1}{3}N^3)\f$.

  @param a a \f$N \times N\f$ matrix 
  @param calcOK returns false if the calculation is singular and true otherwise
  @return the determinant of a
  */

double determinant(Array2D <qmcfloat> a, bool *calcOK);


/**
  Calculates the inverse of a matrix using a dense LU solver.  This 
  method scales as \f$O(1 N^3)\f$.

  @param a a \f$N \times N\f$ matrix 
  @param calcOK returns false if the calculation is singular and true otherwise
  @return the inverse of a
  */

Array2D <qmcfloat> inverse(Array2D <qmcfloat> a, bool *calcOK);


/**
  Calculates the inverse and determinant of a matrix using a 
  dense LU solver.  This 
  method scales as \f$O(1 N^3)\f$.

  @param a a \f$N \times N\f$ matrix 
  @param inv inverse of a is returned here
  @param det determinant of a is returned here
  @param calcOK returns false if the calculation is singular and true otherwise
  */

void determinant_and_inverse(Array2D<qmcfloat> &a, Array2D<qmcfloat> &inv, 
                             double& det, bool *calcOK);

/**
  Solves a system of linear equations using a dense LU solver.
  this method scales as \f$O(\frac{1}{3} N^3)\f$.

  @param a a \f$N \times N\f$ matrix.  This matrix is destroyed in the 
  calculation.
  @param b the \f$N\f$ dimensional right hand side to solve for.  Result is 
  returned here and the original values are destroyed.
  @param calcOK returns false if the calculation is singular and true otherwise
  */

void linearsolver(Array2D<qmcfloat>& a, Array1D<qmcfloat> &b, bool *calcOK);

#endif



